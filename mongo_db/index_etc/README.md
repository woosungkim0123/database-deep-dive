# 인덱스 기타

## 연산자와 인덱스

### 비효율적 연산자

**$ne**

`$ne`는 지정된 항목을 제외한 모든 인덱스 항목을 살펴봐야 하기 때문에 비효율적입니다. (일반적으로 부정 조건은 비효율적입니다.)

"i" 필드가 인덱스를 갖는 컬렉션에서 `db.example.find({"i" : {"$ne" : 3}})` 쿼리는 3보다 작은 인덱스 항목과 3보다 큰 인덱스 항목을 모두 조사하게 됩니다.

해당 값이 컬렉션에서 큰 부분을 차지할 때는 효율적이지만 그렇지 않다면 거의 컬렉션 전체를 확인해야합니다.

**$not, $nin**

`$not`과 `$nin` 연산자도 마찬가지로 인덱스를 효율적으로 사용하지 못하는 상황에서 전체 테이블 스캔을 유발할 수 있습니다.

**개선 방향**

쿼리 실행 속도를 개선하기 위해, 결과 집합을 축소하는 효과적인 필터링 조건을 적용하여 인덱스를 적절하게 이용하는 것이 중요합니다. 

추가적인 조건을 쿼리에 포함함으로써, 필요한 문서만을 반환하게 하여 전체 성능을 향상시킬 수 있습니다.

### OR

MongoDB는 기본적으로 쿼리당 하나의 인덱스만 사용할 수 있습니다. 

`{"x" : 1}`, `{"y" : 1}` 2개의 인덱스가 있다면 `{"x" : 123, "y" : 456}` 쿼리는 두 인덱스 중 하나만 사용합니다.

그러나 `$or`는 두 개의 쿼리를 수행하고 결과를 병합하기 때문에 `$or`절마다 하나씩 인덱스를 사용할 수 있습니다.

`$or`에서 여러 조건이 같은 문서에 대해 참이 될 경우에도, 해당 문서는 결과 집합에 단 한 번만 포함됩니다.

참고로 `$in` 쿼리는 지정된 배열 내의 요소들의 순서가 결과에 영향을 주지 않습니다.

<br>

## 객체 및 배열 인덱싱

### 내장 도큐먼트 인덱싱

내장 도큐먼트에 인덱스를 만들어 쿼리 속도를 올릴 수 있습니다.

주의할 점은 서브 도큐먼트 전체를 인덱싱하면 서브 도큐먼트 전체에 쿼리할 때만 도움이 됩니다.

`db.test.find({"address.city": "aaa"})` 쿼리에는 address 도큐먼트의 일부분인 city만을 목표로 하고 있기 때문에 address 도큐먼트 전체에 걸려있는 인덱스를 사용할 수 없습니다.

이때는 address.city 필드에 대해 별도의 인덱스를 생성하는 것이 쿼리 성능을 최적화하는 데 더 효과적일 것입니다.

### 배열 인덱싱

배열에도 인덱스를 생성해서 배열의 특정 요소를 효율적으로 찾을 수 있습니다.

```json
{
  "_id": "some_post_id",
  "title": "Interesting Post",
  "content": "This is the content of the post...",
  "comments": [
    {
      "author": "Jane Doe",
      "text": "This is a comment",
      "date": "2024-01-01T12:00:00Z"
    },
    {
      "author": "John Smith",
      "text": "This is another comment",
      "date": "2024-01-02T15:30:00Z"
    }
  ]
}
```

```shell
db.posts.createIndex({"comments.date" : 1})
```

주의할 점은 MongoDB에서 배열에 인덱스를 생성하면, 배열 내의 각 요소마다 인덱스 항목이 만들어집니다. 예를 들어, 게시물에 20개의 댓글이 있다면, 그 게시물은 인덱스 내에 20개의 항목을 가지게 됩니다.

배열에 인덱스를 사용하는 것은 쿼리 성능을 크게 향상시킬 수 있지만, 배열의 크기가 크고 변경이 잦은 경우에는 추가적인 비용이 지속적으로 발생해 성능 저하의 원인이 될 수 있습니다.

만약 배열 전체를 인덱싱하면 배열 자체가 아니라 배열의 각 요소를 인덱싱하게 됩니다.

**다중키 인덱스에 의한 인덱스 폭발**

MongoDB의 다중키 인덱스는 배열의 각 요소에 대해 인덱스 항목을 생성합니다.

문서 내에 두 개의 배열 필드가 있고, 두 배열 모두 인덱싱하려고 할 때 문제가 발생합니다. 
이 경우 MongoDB는 두 배열의 가능한 모든 요소 쌍에 대해 인덱스 항목을 생성하려고 시도합니다. 

만약 각 배열에 n개와 m개의 요소가 있다면, 이론적으로 n*m개의 인덱스 항목이 생성됩니다.

이는 데이터베이스의 성능을 현저히 저하시키는 '인덱스 폭발'을 초래할 수 있습니다.

MongoDB는 한 문서에 두 개 이상의 배열 필드에 대해 다중키 인덱스를 생성하는 것을 허용하지 않습니다. 이는 인덱스 폭발을 방지하기 위한 것입니다.

explain에서 `isMultiKey`가 `true`라면 다중키 인덱스를 사용하고 있다는 것을 의미합니다.

```shell
# 인덱스는 {"x" : 1, "y" : 1}
# 정상 - x 필드의 각 요소에 대해 y 값과 함께 인덱스 항목을 생성합니다.
db.test.insertOne({"x" : [1,2,3], "y" : 1})

# 비정상
db.test.insert({"x" : [1,2,3], "y" : [1,2,3]})
```

두개 이상의 배열 필드에 대해서 만약 인덱싱 한다면 (1,1), (1,2) ... (3,3)까지 모든 조합에 대한 인덱스 항목을 생성하기 때문에 인덱스 폭발이 발생하게 되고 예외가 발생합니다.

<br>

## 인덱스 카디널리티

카디널리티는 컬렉션의 한 필드에 대해 고유값이 얼마나 많은지를 나타냅니다.

`gender`같은 필드는 가질 수 있는 값이 적어서 매우 낮은 카디널리티로 간주되고 `username` 같은 필드는 도큐먼트 마다 유일한 값을 가지므로 매우 높은 카디널리티로 간주됩니다.

일반적으로 필드의 카디널리티가 높을수록 인덱싱에 도움이 됩니다. 왜냐하면 인덱스가 검색 범위를 훨씬 작은 결과 셋으로 빠르게 좁힐 수 있기 때문입니다.

복합 인덱스에서 높은 카디널리티 키를 낮은 카디널리티 키보다 앞에 놓으면 인덱스의 효율성을 높일 수 있습니다.

<br>

## explain() 나머지 항목 알아보기

### needYields

`needYields`는 MongoDB에서 쿼리가 실행되는 동안 발생하는 일시 중지의 횟수를 나타냅니다. 

MongoDB는 대기 중인 쓰기 작업을 처리할 수 있도록 쿼리 실행을 일시적으로 중지(양보)할 수 있습니다. 

### indexBounds

```
"indexBounds" : {
    "age" : [
        "[25.0, 25.0]" 
    ],
    "username" : [
        "[MinKey, MaxKey]"
    ]
}
```

`indexBounds`는 인덱스가 어떻게 사용 되었는지에 대한 정보를 제공합니다.

age에 대한 경계는 [25.0, 25.0]로 설정되어, 오직 age가 정확히 25인 문서만 찾습니다.

username의 경계는 [MinKey, MaxKey]로 설정되어 있습니다. 이는 MongoDB에서 username 필드의 값으로 가능한 모든 값들을 포함시키는 것을 의미합니다. 

즉, username 필드에 대해서는 어떠한 필터링도 적용되지 않고 모든 사용자 이름이 쿼리 결과에 포함될 수 있습니다.

<br>

## 인덱스를 생성하지 않는 경우

인덱스를 사용할 때는 인덱스를 먼저 참조한 후, 해당 인덱스가 가리키는 실제 데이터를 조회하는 과정이 필요합니다. 이는 두 번의 조회 작업을 필요로 합니다. 반면에 컬렉션을 스캔하는 경우에는 단순히 각각의 문서를 차례대로 살펴보면 되므로 더 효율적입니다.

최악의 경우에는 인덱스를 사용하는 것이 컬렉션을 스캔하는 것보다 더 많은 조회 작업이 필요합니다. 이는 컬렉션의 모든 문서를 반환해야 할 때 특히 두드러지며, 이런 경우에는 인덱스를 사용하는 것이 오히려 성능을 저하시킬 수 있습니다.

요약하자면, 인덱스를 사용하는 것이 항상 효율적인 것은 아닙니다. 데이터의 양과 조회 패턴에 따라 인덱스를 적절히 활용해야 합니다. 대부분의 경우에는 선택적인 조회 또는 일부 문서만을 반환해야 할 때 인덱스가 유용하며, 그렇지 않은 경우에는 컬렉션을 스캔하는 것이 더 효율적입니다.

| 인덱스가 유용한 경우 | 인덱스가 유용하지 않은 경우 |
| --- | --- |
| 큰 컬렉션 | 작은 컬렉션 |
| 큰 도큐먼트 | 작은 도큐먼트 |
| 선택적 쿼리 | 비선택적 쿼리 |

<br>

## 일반적인 인덱스 종류

### 고유 인덱스

고유 인덱스(unique index)는 데이터베이스에서 중복 값을 방지하기 위해 사용되는 특별한 타입의 인덱스입니다. 

이 인덱스는 특정 필드(또는 필드의 조합)에 대해 각 도큐먼트의 값이 고유함을 보장합니다. 즉, 해당 인덱스가 적용된 필드에는 중복된 값이 존재할 수 없으며, 모든 값이 유일해야 합니다.

예를 들어, MongoDB에서 firstname 필드에 고유 인덱스를 생성한다면, 데이터베이스 내의 모든 도큐먼트는 서로 다른 firstname 값을 가져야 합니다. 

만약 고유 인덱스가 설정된 firstname 필드에 동일한 값을 가진 새 도큐먼트를 삽입하려고 시도한다면, 데이터베이스는 이 작업을 거부하고 예외를 반환합니다.

```shell
db.users.createIndex({"firstname" : 1}, {unique : true})`
```

고유 인덱스가 설정된 필드에 중복 값이 삽입되려고 할 때 발생하는 예외의 처리는 데이터베이스에 부담을 줄 수 있습니다.

따라서 고유 인덱스는 데이터에 중복이 상대적으로 드물게 발생할 것으로 예상되는 경우에 가장 효율적으로 사용됩니다.

만약 중복이 많이 발생할 것으로 예상되는 경우는 고유 인덱스보다는 중복을 허용하는 설계를 고려하거나, 애플리케이션 레벨에서 중복을 미리 필터링하는 등의 방법으로 문제를 해결하는 것이 더 효율적일 수 있습니다.

**주의**

문서에 키가 존재하지 않으면 인덱스는 그 도큐먼트에 대한 값을 null로 저장합니다. 

고유 인덱스를 생성한 후 인덱싱 된 필드가 없는 문서를 2개 이상 삽입하려고 시도하면 이미 null 값을 갖는 문서가 존재하기 때문에 실패하게 됩니다. 이 문제는 부분 인덱스로 해결할 수 있습니다.

### 부분 인덱스

고유 인덱스는 null을 값으로 취급하므로 키가 없는 도큐먼트가 여러 개인 고유 인덱스를 만들 수 없습니다. 

대부분의 경우 키가 존재할 때만 고유 인덱스가 적용되도록 하는 경우가 많습니다.

부분 인덱스(partial index)는 MongoDB에서 특정 조건을 만족하는 문서에만 인덱스를 적용하는 방법입니다.

```shell
db.users.createIndex({"username" : 1}, {unique : true, "partialFilterExpression" : { "username" : { "$exists" : true } }})
```

예시처럼 부분 인덱스를 적용하면 "username" 필드가 존재하는 문서에 대해 고유 인덱스를 생성하도록 지정되어 있습니다.
"username" 필드가 없는 문서는 이 인덱스의 영향을 받지 않으며, 중복성에 대한 제약도 적용되지 않습니다.

**부분 인덱스로 인한 결과 생략**

```shell
# 부분 인덱스 적용 전
db.food.find({"x" : {"$ne" : 2}})
```

```
{"_id" : 0}
{"_id" : 1, "x" : 1}
{"_id" : 3, "x" : 3}
```

```shell
# x에 대한 부분 인덱스 생성
db.food.find({"x" : {"$ne" : 2}})
```

```
{"_id" : 1, "x" : 1}
{"_id" : 3, "x" : 3}
```

만약 필드가 없는 문서가 필요하면 hint를 사용하여 테이블 스캔을 강제할 수 있습니다.

또, 부분 인덱스는 반드시 고유할 필요는 없습니다. 고유하지 않는 부분 인덱스를 만드려면 unique 옵션을 제외하면 됩니다.

### 복합 고유 인덱스

복합 고유 인덱스(composite unique index)는 두 개 이상의 필드로 구성된 인덱스로, 이러한 인덱스에는 각 필드의 조합이 최대 한 번만 나타날 수 있습니다. 
즉, 각 인덱스 항목의 값들의 조합이 유일해야 합니다

```shell
# 정상적으로 삽입
db.users.insert({"username" : "bob"})
db.users.insert({"username" : "bob", "age" : 25})
db.users.insert({"username" : "fred", "age" : 25})
```

하지만 같은 조합의 필드들로 이미 존재하는 도큐먼트를 다시 삽입하려고 할 때는 중복 키 오류가 발생합니다.

이러한 복합 고유 인덱스는 두 개 이상의 필드를 조합하여 데이터의 무결성을 보장하고 쿼리의 성능을 최적화하는 데 사용됩니다. 각 필드의 조합이 유일한 경우에만 도큐먼트가 삽입될 수 있기 때문에 중복 데이터를 방지할 수 있습니다.
