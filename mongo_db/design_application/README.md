# 애플리케이션 설계

## 스키마 설계 고려사항

가장 좋은 설계 접근 방식은 애플리케이션이 원하는 방식으로 데이터를 표현하는 것입니다.

### 고려 사항
 
- 도큐먼트는 최대 16MB까지만 저장할 수 있습니다.

- 갱신은 전체 도큐먼트를 다시 쓰는 작업이므로, 도큐먼트가 커질수록 갱신 작업이 느려질 수 있습니다.

- 쿼리에 사용되지 않는 데이터는 다른 컬렉션, 자주 사용하지 않는 데이터도 다른 컬렉션 분리를 고려하는 것도 좋은 방법입니다.

- 동적(읽기/쓰기) 데이터와 정적(대부분 읽기) 데이터를 분리를 고려하는 것도 좋은 방법입니다.

## 스키마 설계 패턴

### 서브셋 패턴

자주 접근하는 컬렉션과 자주 사용하지 않는 컬렉션을 분리하는 패턴입니다.

예시로 최근 리뷰 10개를 보여주는 컬렉션을 따로 만들어서 사용함으로써 자주 사용하는 데이터를 빠르게 조회할 수 있습니다.

만약 나머지 리뷰를 보고 싶다면, 다른 컬렉션으로 조회하도록 하면 됩니다.

### 확장된 참조 패턴

데이터의 중복을 허용하여, 조회(쿼리) 성능을 향상시키는 방법입니다.

관계형에서는 조인으로 관련된 데이터를 가져오지만 MongoDB에서는 이러한 방식은 성능 저하를 가져올 수 있습니다.

조인 대신 중복을 허용하여 조회 성능을 향상시키는 방법을 사용합니다.

주문 도큐먼트에 자주 접근하는 필드(예: 고객 이름, 배송 주소 등)를 주문 도큐먼트에 자체에 복제해서 저장함으로써 참조 없이 하나의 도큐먼트로 필요한 정보를 가져올 수 있습니다.

단점으로는 데이터 일관성을 유지하기 위한 추가적인 노력이 필요할 수 있습니다. 예시로 고객 이름이 변경되면 모든 주문 도큐먼트에서 고객 이름을 업데이트 해야할 수도 있습니다.

### 근사 패턴

리소스가 많이 드는 계산이 필요하지만 높은 정확도가 반드시 필요하지 않은 상황에 유용합니다.

이미지나 게시글의 추천수, 조회수 등을 예시로 들 수 있습니다.

근사 패턴을 적용해 추천이나 조회 수가 1회가 아니라 100회가 될때마다 카운터를 갱신하면 쓰기 횟수를 크게 줄일 수 있습니다.

### 정규화 vs 비정규화

일반적으로 정규화는 쓰기를 빠르게하고 비정규화는 읽기를 빠르게 합니다.

<br>

## 팔로우 기능으로 보는 설계 방법

설계에 정답은 없으며 밑에 케이스는 상황에 따라 장점이 될 수도 있고 단점이 될 수도 있습니다.

### 사용자가 자신이 팔로우 한 사람을 포함하는 케이스

```
{
    _id: "ObjectId("51250a62d12kd21kdkdkd")",
    name: "user1",
    following: [
        ObjectId("51250a6bd380e4c5c8b6a4d9"),
        ObjectId("51250a6bd380e4c5c8b6a4e0")
    ]
}
```

이 방식의 장점은 특정 사용자가 관심 있는 다른 사용자들을 쉽게 찾을 수 있습니다.

그러나 새로운 글이 발행될 때, 그 활동에 관심 있을 수 있는 모든 사용자를 찾아내기 위해서는 모든 사용자의 도큐먼트를 조회하는 단점이 있습니다.

### 게시자 도큐먼트에 팔로워를 포함하는 케이스

```
{
    _id: "ObjectId("51250a6bd380e4c5c8b6a4d9")",
    name: "user1",
    followers: [
        ObjectId("51250a62d12kd21kdkdkd"),
        ObjectId("51250a6bd380e4c5c8b6a4e0")
    ]
}
```

이 방식은 알림을 보내야 할 때, 게시자의 도큐먼트만 조회하면 된다는 장점이 있습니다.

그러나 팔로우하는 사람을 모두 찾아내기 위해서는 모든 사용자의 도큐먼트를 조회해야 한다는 단점이 있습니다.

### 정규화 및 다른 컬렉션에 분리

```
{
    _id: "ObjectId("51250a62d12kd21kdkdkd")", // 팔로우 대상의 id
    follwers : [
        ObjectId("51250a6bd380e4c5c8b6a4d9"),
        ObjectId("51250a6bd380e4c5c8b6a4e0")
    ]
}
```

팔로우 필드는 반환될 필요가 없을 때가 많기 때문에 사용자 도큐먼트에 포함시키지 않고 별도의 컬렉션으로 분리함으로써 단점을 극복할 수 있습니다.

이런 식의 정규화는 지나칠 때가 많지만 자주 반환되지 않으면서 매우 자주 변하는 필드에 유용합니다.

### 기타, 유명인 사용자로 인한 연속 도큐먼트

```
{
    _id: "ObjectId("51250a62d12kd21kdkdkd")",
    name: "user1",
    tbc: [ 
        ObjectId("51250a6bd380e4c5c8b6a4d9"),
        ObjectId("51250a6bd380e4c5c8b6a4e0")
    ],
    followers: [
        ObjectId("aaaaaaaaaaaaaaaaaa"),
        ObjectId("bbbbbbbbbbbbbbbbbb"),
        // ... 
    ]
}

// 연속 도큐먼트
{
    id: "ObjectId("aaaaaaaaaaaaaaaaaa")",
    followers: [
        ObjectId("51250a62ddsaaaadasdsaads"),
        ObjectId("51250a6bd380e4c5c8b6a4e0")
        // ...
    ]
}
{
    id: "ObjectId("bbbbbbbbbbbbbbbbbb")",
    followers: [
        ObjectId("51250a62ddsaaasdadsad34"),
        ObjectId("51250a6bd380e4c5c8b6a35")
        // ...
    ]
}
```

To Be Continued 배열을 사용해 도큐먼트 조회를 돕는 방법입니다.

<br>

## 데이터 조작을 위한 최적화

### 읽기와 쓰기 최적화

읽기와 쓰기 성능을 분석해 어떤 부분에서 병목 현상을 일어나는지 파악하는 것이 중요합니다.

읽기 최적화는 일반적으로 올바른 인덱스를 사용해서 하나의 도큐먼트에서 가능한 많은 정보를 반환하는 것과 관련이 있고,
쓰기 최적화는 인덱스 개수를 최소화하고 갱신을 효율적으로 처리하는 것과 관련이 있습니다.

빠른 쓰기와 빠른 읽기 최적화 사이에는 트레이드 오프가 있으며 애플리케이션에서 어떤 부분을 중요하게 생각하는지에 따라 다릅니다.

쓰기와 읽기의 비율 또한 최적화 요소 입니다. 

만약 애플리케이션에서 쓰기가 더 중요한 요소지만 각 쓰기에 대해 읽기가 수천 번 수행된다면 읽기 최적화가 더 중요할 수 있습니다. (상황마다 다 틀림)

### 오래된 데이터 제거

짧은 시간 동안만 중요한 데이터는 그 이상이 지나면 저장 공간만 낭비하게 됩니다. 

첫번째 방법은 제한 컬렉션을 사용해서 크기를 설정하고 오래된 데이터가 끝으로 밀려나게 하면 됩니다. 

이 방법은 쉬우나 기능적으로 제한적이고 컬렉션이 유지되는 시간을 일시적으로 줄이기 때문에 급증하는 트래픽에 취약합니다.

두번째 방법은 TTL 인덱스를 사용해서 일정 시간이 지나면 자동으로 삭제되게 하는 방법 등 미세하게 설정할 수 있습니다.

쓰기를 매우 많이 수행하는 컬렉션에 사용하기에는 성능적인 문제가 있을 수 있습니다.

세번째는 여러 개의 컬렉션을 사용하는 방법인데 한달에 하나의 컬렉션을 사용한다고하고 달마다 컬렉션을 바꾸는 방법입니다.

이 방법은 어떠한 양의 트래픽에도 견딜 수 있지만, 동적 컬렉션 이름을 사용해 여러 데이터베이스를 조회하므로 애플리케이션 구축이 복잡해질 수 있습니다.

